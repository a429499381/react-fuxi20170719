匹配优先量词 * + ？ {num,num}

忽略优先量词 *? +? ?? {num,num}?

占有优先量词  *+ ++ ？+ {num,num}+

固化分组 （?>...)


命名捕获 (?<Name>...)

条件判断 （？if then | else)

js 正则 是 NFA 普通算法  支持 忽略优先量词

正则通用规则
1. 优先选择最左端（最靠开头）的匹配结果。
2. 标准的匹配量词（* + ？ 和 {m,n}) 是匹配优先的。



\d  表示数字
\D  非数字字符

\s  空格
\S   非空格


\w   字符 （包含数字 字符 下划线）
\W   非字符

+  表示至少一个

\b \b 前后边界

（） 分组$1

{num}  num 表示重复几次 

^ 表示取反 在开头表示 开头意思

$ 表示结尾

\a  表示重复某个子项目

／(a)(b)(c)\1/  匹配 abca
／(a)(b)(c)\2/  匹配 abcb

[/-]  [] 表示或者   ／ 或者 -
[0-9] 表示 0-9 任意数字
[^0-9] 表示 非0-9 任意字符
[a-zA-z] 表示大小写a-z
[a-zA-z-] 表示大小写a-z -横线

. 表示一个 除回车 换行之外所有字符

g 表示全文匹配

i 表示不区分大小写

m 多行匹配

？ 出现0次或者一次（最多一次）

+ 出现一次或者多次 （最少一次）

* 出现零次或多次（任意次）

{0,5} 最少0次 最多5次
{5} 出现5次
{5,} 至少出现5次

默认正则表达式 是贪婪模式  {2,5} 最少2次最多5次， 会一直匹配达到5次， 
{2,5)？  属于非贪婪模式， 一旦匹配达到两次 停止匹配

?: 表示 不使用分组 定义变量   （\d{1})/（?:\d{2})/（\d{3})   $1 =  （\d{4})  $2= （\d{3}) 

exp(?=assert)  正向前瞻
exp(?!assert) 负向前瞻

'a2*3'.replace(/\w(?=\d)/g, 'x')  前面是一个单词后面必须是数字才能正确匹配 替换为'x'

var reg = /\d/g
var ts = '$1a2b3c4d5e'
reg.test('4')  第一次返回true  第二次 false 

reg.exec('344')  返回匹配到内容数组

ts.match(reg) 返回匹配到内容数组

ts.split(/\d/g/)  用数字当作分隔符返回数组

ts.replace(/\d/g, 2) 把数字替换为2
ts.replace(/\d/g, function(match,groun1,group2 index, origin){}) 把每次匹配到的结果 
调用fuction

match 匹配到结果
groun1.  如果正则有（）分组 才有， 没有，index 为第二个参数
orgin 原来字符串


获取 li 包裹内容 有待完善
<li\b\s{1,5}?[\d\D]{1,1000}(<\/li\b>)

去数字3的倍数 并且匹配后面必须有至少一个数字
(?=(\d\d\d)+\b)
(?=(\d\d\d)+(?!\d))  匹配有差别， 要注意分析

匹配字符  
"浮动房贷首付 Thfdf  fd   3431431232132323233249348311223223943 is  fdfdsfds;
 the 1970s"

 匹配网址
 http://[\.&=?!/%:@'$0-9a-zA-z,/]+(.com|.cn|.info|.edu)

 完美匹配 li 包裹内容 噢耶
 (?!</?li>)<li\b\s?[\d\D]+?(<\/li\b>)

 另外一个 匹配方法 li 包裹内容
 <li\b([\d\D])+?</li>(?!</li\b>)

获取 href 标签内容
(/\d+/\D+/\d+)

获取span 内的  任意字符不包含 > 尖括号
([^([hidden;']>)]+)(?=</span>\s)
改进版本
([^>]+)(?=</span>\s)   实际 [hidden;']  没有作用


提取标签内 color的内容
color:\b.+(?="|')

[^-](color:[^"';]+)
([^-]\bcolor\b)[^;'"]+

